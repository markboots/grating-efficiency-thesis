\chapter{Implementation of theory: What people and I did to implement the theory using computers}

In the initial stages of the spectrometer design project, we used \texttt{\textbf{Gradif}} -- a program written by one of the original authors of the differential theory -- for all of our calculations and optimizations.  We also built a user interface for this program, to speed up the process of entering input and running multiple calculations.  More recently, we implemented a new, open-source grating efficiency calculator from scratch to address some shortcomings of the \texttt{\textbf{Gradif}} code: performance, stability, and the ability to handle arbitrary grating shapes.  A secondary benefit of this last project is the opportunity to share it freely with the grating/beamline design community, and to extend it in conjunction with other researchers.

In this chapter, we examine the existing grating software options, describe our experience using the \texttt{\textbf{Gradif}} code, and review the development and validation of new grating efficiency software.

\section{Pre-existing grating efficiency software}
Currently there are four commercial or closed-source programs available for calculating diffraction grating efficiencies (Table \ref{commercialComparison}).  \texttt{\textbf{PCGrate}} implements the modified integral method \cite{Gor02} and is the most general, although also the slowest and most expensive.  \texttt{\textbf{GSolver}} uses the Rigorous Coupled Wave approximation \cite{Moh82}\cite{Moh86} and can therefore handle any grating shape, subject to the previously noted issues with the staircase approximation in TM polarization.  Two implementations of the differential method are available: Professor Neviere sells an implementation called \texttt{\textbf{Gradif}}, and the \texttt{\textbf{REFLEC}} program is used internally at the BESSY synchrotron.  Although the differential method is general, both of these implementations are limited to predefined grating profiles (rectangular, blazed, trapezoidal, and sinusoidal).

Table \ref{commercialComparison} compares the features, cost, and performance of these programs.

\renewcommand{\arraystretch}{1.8}
\begin{table}
\topcaption{Comparison of commercially-available grating efficiency software}
{\footnotesize
\begin{tabularx}{\textwidth}{@{} p{1.7in}p{1in}p{0.8in}XXX @{}}
\toprule
        Name and Organization                                                        & Method                         & Price (USD)                                            & Graphical User Interface & Arbitrary Shapes        & Comparative Run Time \\ \midrule
        \texttt{\textbf{PCGrate-SX 6.5}}\newline IIG, Inc.\newline http://www.pcgrate.com & Modified Integral Method (MIM) & GUI: 15749\newline Console: 11249\newline Both: 22499 & Available                & Yes                     & ~                    \\ 

        \texttt{\textbf{GSolver 5.2}} \newline Grating Solver Development Co. \newline http://www.gsolver.com            & Rigorous Coupled Wave (RCW)    & 795                                                    & Yes                      & Yes & ~                    \\  
        \texttt{\textbf{Gradif}}\newline Dr. Michel Neviere \newline m.neviere@free.fr                                                    & Differential Method            & 6090                                                   & No                       & No                      & ~                    \\ 
        \texttt{\textbf{REFLEC}}\newline Dr. Michael Krumrey\newline Michael.Krumrey@ptb.de                 & Differential Method            & 0                                                      & No                       & No                      & ~    \\
\bottomrule
   \end{tabularx}
}
\label{commercialComparison}
\end{table}
\renewcommand{\arraystretch}{1.2}


\section{Improving the usability and efficiency of \texttt{\textbf{Gradif}}}
The Canadian Light Source purchased the \texttt{\textbf{Gradif}} code and made it available for this project.  However, there were two challenges involved in applying the code:
\begin{enumerate}
\item The code itself is a Fortran-language program that provides no user interface.  Instead, to calculate an efficiency data point for a grating at just one energy, approximately 30 numbers must be entered into a blank screen, with no prompts, in the correct order.  These numbers define the grating geometry, the coating/layer thicknesses, the incidence conditions, the integration parameters, and also the complex refractive indices of the layers and the substrate.\footnote{These last two values will change as a function of photon energy, since the refractive index varies with wavelength, so we need to look them up for each data point.}  Using this program requires a time-consuming and error-prone data entry process.
\item In the event of an error made during data entry, one of many grating parameters could end up outside the narrow region of convergence where the code is able to  numerically integrate a solution successfully.  When this happens, the program runs forever in an infinite loop, with no feedback that the calculation has failed.  This region of convergence is not well established, so even when data entry errors are avoided, it is possible for a user to specify a valid grating that is -- for example -- too deep to be calculated.  Without user feedback, it is impossible to know if the calculation is still running successfully, or if it has failed into this infinite loop.
\end{enumerate}
To beat these two challenges, we built a web-based graphical interface, and carefully modified the Fortran source code to detect convergence failures.
\subsection{Visual interface to the \texttt{\textbf{Gradif}} code}
Figure \ref{3b} shows a screenshot of the graphical user interface (GUI) that we built to help us perform efficiency calculations efficiently.  The interface served as a wrapper to generate input for the \texttt{\textbf{Gradif}} code, manage running a set of calculations, and extract the results.

\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
   \centering
   \includegraphics[scale=0.6]{Chapter3/3b_nephiere/3b_1.pdf} \\
%\vspace*{0.25in}
   \includegraphics[scale=0.6]{Chapter3/3b_nephiere/3b_2.pdf}
   \caption{This web application provides a graphical user interface for calculating grating efficiencies. Forms prompt users for the grating parameters.}
   \label{3b}
\end{figure}

The interface was implemented as a web-based application, so it could be used from anywhere through a browser, without having to distribute the \texttt{\textbf{Gradif}} code or install anything on a person's individual computer.  Users described the grating parameters and incidence scenario through a form that prompted them for the necessary information based on the type of grating (Figure \ref{3b}).  When the calculation finished, an efficiency plot would be generated, and users could also download data tables of their calculations.  These tables were also archived so they could be retrieved later.

It supported the following features:
\begin{itemize}
\item \textbf{Grating types}\\
The form would request the geometry parameters required for each of the supported grating types: rectangular, blazed, trapezoidal, and sinusoidal profiles.

\item \textbf{Order and polarization}\\
Users could configure which inside and outside orders were plotted, and specify the polarization of the incident light: TE, TM, or natural light (randomly polarized).

\item \textbf{VLS gratings}\\
To model variable line space (VLS) gratings, the interface accepted the VLS parameters in conventional notation (linear, quadratic, and cubic corrections) and used these to calculate the groove density and corresponding efficiency at a user-determined number of points along the grating surface; the overall efficiency was taken as an average of these.

\item \textbf{Efficiency plots as a function of wavelength}\\
In the simplest mode, the system generated a plot of the efficiency in the desired orders as a function of wavelength, holding all the other parameters constant (Figure \ref{3b_3}).  This would represent the typical case of testing how a grating would perform in a beamline.

\begin{figure}[p] %  figure placement: here, top, bottom, or page
   \centering
   \vspace*{-.5in}
   \includegraphics[scale=0.6]{Chapter3/3b_nephiere/3b_3.pdf} \\
%\vspace*{0.25in}
   \includegraphics[scale=0.6]{Chapter3/3b_nephiere/3b_4.pdf}
   \caption{This web application provides a graphical user interface for calculating grating efficiencies. The results are plotted, and users can download a text-based table for further analysis.}
   \label{3b_3}
\end{figure}

\item \textbf{Complex scans over arbitrary grating parameters}\\
The interface also offered flexibility to test arbitrary relationships along incidence angle, energy, geometry, and other parameters. This feature was most efficiently used in conjunction with a spreadsheet or other data analysis program to fill in the grating parameters and interpret the output tables.

\item \textbf{Database of optical materials and refractive index}\\
We also developed a database of common grating substrate and coating materials, so that the interface could automatically look up their complex refractive index as a function of photon energy.  This information was calculated using the semi-empirical Henke data tables of the x-ray atomic scattering factor \cite{Hen93} discussed in Section \ref{secHenke}.  The library is valid from 30 eV to 10~000 eV, but is known to have poor accuracy in the vicinity of absorption edges.

\item \textbf{Mirror reflectivity}\\
As an additional tool for beamline designers, we implemented the ability to calculate the reflectivity of a simple mirror using any of the materials in the refractive index database.  Mirror reflectivity was computed as a function of incidence angle and photon energy using the complex Fresnel equations \cite[p. 40]{Fow89} for both polarizations.

\item \textbf{Control of numerical precision}\\
An `Options' page (Figure \ref{3b_5}) allowed users to configure the numerical precision used in the calculations.  The two critical factors are the number of integration steps used in the numerical integration of the particular solutions for the $A_n^{(m)}$ and $B_n^{(m)}$ coefficients at each layer, and the number of Fourier coefficients $2N+1$ used in the truncated sum.  The defaults we chose ($N=31$; 401 integration steps) were found to produce accurate results and reasonable performance across the entire soft x-ray range, as long as the coating thickness was less than 0.5um.   However, prudent designers should still do convergence tests for any high-stakes results, by repeating the calculations and comparing against efficiencies computed using larger values.  This technique can also be used to find the minimum number of Fourier coefficients that are required before the results start to disagree.  (This can be helpful to optimize the computation speed before running a large number of calculations on similar gratings at similar wavelengths.)
\end{itemize}

\begin{figure}[p] %  figure placement: here, top, bottom, or page
   \centering
   \includegraphics[scale=0.6]{Chapter3/3b_nephiere/3b_5.pdf}
   \caption{This Options page configures the numerical precision of the calculations, the diffraction orders of interest, and the polarization of the incident light.}
   \label{3b_5}
\end{figure}

\subsection{Detecting integration failures}
When an integration fails, the original \texttt{\textbf{Gradif}} code is programmed to repeatedly retry the calculation using successively thinner S-matrix layers.  Sometimes this strategy is successful, but in many cases the integration fails regardless of the layer thickness, leading to an infinite loop.  
The Fortran code was written using a 1970's-era programming approach, including substantial use of global variables and GOTO statements.  (These two features are heavily discouraged in modern programming methodologies.)  As a result, the code is hard to trace, but we were able to insert a counter to detect when a numerical integration fails after many repeated attempts.  Our modification allows the calculation to exit with an error message, rather than run indefinitely.

\subsection{Online access}
%Since we released the user interface under an `open-source' license, it can be upgraded or enhanced by anyone with an interest in beamline design and grating efficiency.  Julian Miller, a summer student in the metrology department at the CLS, recently created an updated version of the interface to support multi-threaded calculations and add more options for incidence configurations.  To the original `constant incidence angle' mode, he added a `constant included angle' mode, used in many monochromators, which tilts the grating as a function of photon energy to maintain a constant angle between the incident and outgoing beam in the desired order.  Since every grating efficiency calculation (at a single energy) is independent, they can be run in parallel; this takes advantage of modern multi-core processors, and dramatically speeds up the creation of a user's plot or data set.  In the future, this could be extended even further to spread calculations over a cluster of computers, or on distributed hardware in a `cloud computing' network.
Because the user interface ran as a web application, it could be (and was) accessed by beamline designers from all over the world.  In one example, it was used by Professors Coryn Hague and Gheorghe Sorin Chiuzbaian to improve the design of a new beamline for the SOLEIL synchrotron (TODO ref).  The calculations could be requested by anyone from anywhere, but they all ran on a single server computer at the University of Saskatchewan.  Unfortunately, the underlying \texttt{\textbf{Gradif}} code is commercial software, and while we were licensed to run it on this machine, recent communication from Professor Neviere indicated that he was unhappy with this level of access to results calculated using his code.  As a result, we disabled public access to the original website.

\section{Improved, open-source grating efficiency software}
\subsection{Motivation for new grating software}
The \texttt{\textbf{Gradif}} code allowed us to complete the design and optimization of the REIXS spectrometer in Chapter 6; however, several limitations provided motivation for improvement:
\begin{enumerate}
\item \textbf{Unpredictable instability}: For some rare but reasonable grating inputs, the numerical integration process becomes unexpectedly unstable. We expect this to happen for deep gratings outside of \texttt{\textbf{Gradif}}'s convergence range, but in other cases the failed calculations are surrounded by successful calculations. The random failures can usually be avoided by tweaking the number of integration steps or the number of Fourier coefficients, but not in a consistent or predictable way.
\item \textbf{Performance}: The run time of a single calculation depends on the grating depth, number of Fourier coefficients, and number of integration steps required for convergence; it can range from two seconds for shallow gratings to well over 30 seconds.  At this speed, it is feasible to calculate the efficiency of a single grating over a range of wavelengths; however, if we want to do global optimization or fitting (Chapter 7), faster run times are desired.  The \texttt{\textbf{Gradif}} code is inherently single-threaded, although independent calculations can be run simultaneously by invoking the program multiple times.
\item \textbf{Arbitrary groove profiles}: As we will see in Chapter 7, grating manufacturing rarely produces the perfect, intended groove profile.  To model real-world gratings, we need the ability to represent profiles of arbitrary shape; for example, point-wise defined curves derived from atomic force microscopy (AFM) measurements.
\item \textbf{Open online access}: Finally, since grating efficiency has rarely been considered during many past beamline designs, we believe the soft x-ray instrument design community would benefit from having access to an easy-to-use, easy-to-access grating efficiency calculator.  It became obvious after taking down the original web interface to \texttt{\textbf{Gradif}} that there was a strong demand for this service.
\end{enumerate}

These four factors motivated us to write a new implementation of the differential method from scratch.
\subsection{Features and limitations}
We envision two different software activities (``\emph{use-cases}'') that would be helpful during the design phase of a soft x-ray instrument:
\begin{enumerate}
\item \textbf{Producing efficiency curves}: For a potential grating specification, a designer might want to predict its efficiency over the range of wavelengths or photon energies where that grating would be used.  (For examples, see Figures \ref{4h-1}, \ref{4h-2}, and \ref{4h-3} in Chapter 6.)

These curves might assume a constant incident angle (for example, in a fixed-incidence spectrometer), or the designer might want to vary the incidence angle according to some function of the wavelength (for example, when designing a constant included angle (CIA) monochromator).
\item \textbf{Optimization}: Instead of simply predicting the efficiency, a designer probably wants to optimize it by varying the grating parameters within an acceptable range.  The grating parameters also affect the focussing and resolution characteristics of the instrument, therefore there will usually be constraints for some of the parameters. In other cases, the designer might wonder if a certain increase in efficiency is worth the trade-off it causes in resolution.

A global optimization method is desired here for two reasons: the efficiency function may have several local maxima, and the parameters have hidden dependencies.  (For example, we show in Section \ref{blazeAngle} that the optimal ``blaze angle'', or the angle at the base of a triangular groove profile, is highly coupled to the incident angle, order, groove width, and wavelength.)
\end{enumerate}

Finally, there is one computationally intensive use-case that would be valuable to grating manufacturers and theorists:

\begin{enumerate}[resume]
\item \textbf{Fitting grating parameters to measured efficiency}: To validate and improve any of the modelling methods, we need to actually measure the efficiency of real gratings.  This can be done on special beamlines that have been designed with \textbf{diffractometer} chambers for this purpose; we discuss our own measurements in Chapter 7.  Some of the real-world grating parameters are hard to measure; for example, we found that the micro-structure of the surface (oxidation and roughness) dramatically affects the efficiency, but it is difficult to measure the roughness and oxidation levels directly.  If these parameters could be incorporated into the efficiency model, a curve-fitting search could determine the parameters that best match the theoretical to the measured efficiency curves.
\end{enumerate}

We wrote the new grating software in modular components so that it could be applied to all three of these use-cases.  The grating solver (implementation of the differential method) is complete, along with an \emph{application programming interface} (API) to integrate the solver into third-party programs.  A command-line user interface enables single efficiency calculations or the calculation of efficiency curves in three different incidence modes.  Work continues toward a web-based user interface, and a built-in global optimization and fitting facility.  (Optimization and fitting can already be done using third-party tools, using the command-line interface or API to evaluate single efficiencies.)

\subsubsection{Features}
The solver and command-line interface support the following features:
\begin{itemize}
\item \textbf{Standard grating shape profiles}: rectangular, triangular, trapezoidal, and sinusoidal.
\item \textbf{Custom grating shape profiles}: any point-wise defined profile.
\item \textbf{Coatings}: an optional coating layer of a different material on top of the grating, generated by translating the grating profile vertically.  The coating can be thicker than the groove depth, leaving a homogeneous layer between the coating grooves and the grating grooves, or it can interpenetrate the grating grooves.
\begin{itemize}
\item Note: Coatings are not yet supported on custom profiles.
\end{itemize}
\item \textbf{Material Database}: automatic lookup of complex refractive indexes for common materials based on the Henke tables.
\item \textbf{Incidence scanning modes}: calculation of common efficiency curves with a single command:
\begin{enumerate}
\item \texttt{constantIncidence} mode calculates the efficiency over a range of wavelengths (or photon energies) at a constant incidence angle.
\item \texttt{constantIncludedAngle} mode automatically varies the incidence angle as a function of wavelength, to satisfy a condition of a constant deviation from the incident light to the outgoing order $n$.  (This is the operating mode for many monochromator designs.)  The incidence angle $\theta_{2}$ is computed from the grating equation \eq{gratingEquation} and the requirement that the included angle $\phi = \theta_{2} + \theta_{2,n}$:
\begin{eqnarray}
\theta_{2} &=& \arcsin \left(  \frac{-n\lambda}{2 d \cos(\phi/2)}  \right) + \phi/2
\end{eqnarray}
\item \texttt{constantWavelength} mode calculates the efficiency over a range of incidence angles at a constant wavelength.
\end{enumerate}
\item \textbf{Parallel calculations}:
\begin{itemize}
\item Fine parallelization of a single calculation
\item Coarse parallelization of many efficiency calculations using high-performance computing resources
\end{itemize}
\end{itemize}

\subsubsection{Limitations}
The current version has two main limitations; work is ongoing to address both of these:
\begin{enumerate}
\item The solver currently only calculates the efficiency for TE polarization.  Since the TE and TM polarization efficiencies converge at grazing incidence, for soft x-ray optics used in grazing incidence there is very little difference between the TE and TM polarization.  Figure \ref{TEvsTM_88} shows a grating at 88 degrees incidence calculated using the \texttt{\textbf{Gradif}} program; the difference between TE and TM efficiency is generally less than 5\% (relative).  The shape of the TE and TM curves are also identical; therefore, designers currently using the TE results for optimization should not be misled even if their actual incidence configuration includes TM light.  However, implementing the TM solver is necessary for completeness, and accuracy at more normal incidence angles (Figure \ref{TEvsTM_80}).
\item Interpenetrating coatings are not yet supported for custom (point-wise defined) groove profiles.
\end{enumerate}
\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
   \centering
   \includegraphics[scale=0.8]{Extended/Polarization/TEvsTM_88.pdf} 
   \caption[The difference in efficiency between TE and TM polarization is very small for grazing-incidence optics.]{The difference in efficiency between TE and TM polarization is very small for grazing-incidence optics.  For this grating at 88 degrees incidence, the difference is less than relative 5\%.  Grating: 1200 lines/mm, 1.48\dg blaze angle, Nickel coating. }
   \label{TEvsTM_88}
\end{figure}
\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
   \centering
   \includegraphics[scale=0.8]{Extended/Polarization/TEvsTM_80.pdf} 
   \caption[At more normal incidence, the efficiency is different for TE and TM polarization.]{At more normal incidence, the efficiency is different for TE and TM polarization.  This is the same grating as Figure \ref{TEvsTM_88} but at 80 degrees incidence; the difference becomes up to relative 20\%.  However, because the shapes of the curves are identical, optimization of the TE efficiency provides the same results as optimization of the TM efficiency.  Grating: 1200 lines/mm, 1.48\dg blaze angle, Nickel coating.}
   \label{TEvsTM_80}
\end{figure}

\subsubsection{Improving Stability}
The solver uses two techniques to improve integration stability of the ordinary differential equation \eq{matrixDE}.  \texttt{\textbf{Gradif}} uses a fixed number of vertical integration steps, regardless of the height of the grating or the thickness of the S-matrix layers.  Therefore, the user needs to manually estimate the appropriate number of integration steps necessary for convergence of a specific problem.  Instead of a fixed step size, we use an adaptive step size integration algorithm with error prediction, to ensure that the error at every integration step remains under a defined tolerance.  This allows us to automatically use smaller steps where the problem is sensitive, and larger steps for faster performance whenever possible.  Users no longer need to manually estimate the appropriate number of integration steps, although they can adjust the tolerance setting if required for exceptional problems.  (The default tolerance setting was determined over a range of typical soft x-ray grating inputs to offer good performance while ensuring convergence and a wide margin of stability.)  Although the variable step size method offers better accuracy, better reliability, and less possibility of operator error, it comes with one performance trade-off: we can no longer share computations of the $M(y)$ matrix and $k^2_n(y)$ expansions across all the trial solutions; each trial solution will potentially need to evaluate them at different values of $y$.

For the ODE integration algorithm, we experimented with a variety of explicit methods,
\begin{itemize}
\item classical 4th order Runge-Kutta,
\item Runge-Kutta-Fehlberg,
\item multistep Adams-Bashforth,
\end{itemize}
and implicit methods,
\begin{itemize}
\item second and fourth-order Runge-Kutta,
\item Bulirsch-Stoer, and
\item multi-step backward difference.
\end{itemize}
We found that the results were insensitive to the integration method to more than six significant figures, and that the explicit methods (predictably) ran much faster than the implicit ones.  Currently, we use a method under the family of \emph{Adams-Bashforth multistep methods}, which uses an explicit Adams-Bashforth predictor and an implicit Adams-Moulton corrector \cite{Byr75}. It was found to offer the highest performance, since the error estimation requires far fewer function evaluations than  the classical Runge-Kutta algorithm.

The solver's second stability improvement comes from automatically estimating the number of S-matrix layers required to keep the integration values bounded within significance.  The largest values of the exponential functions $[\exp(i \beta_n y)]$ occur for the largest orders $-N$ and $N$ when they are evanescent, where $\beta_{(\pm N)} \approx \pm i 2\pi N/d$.  To estimate the maximum size these will reach after integration over a layer of thickness $h$, we can bound them with an assumed homogeneous layer with the same index as the vacuum:
\begin{align}
\textrm{Maximum Value} &\approx \left|  e^{i \beta^{(M)}_{(\pm N)} h}  \right|
\end{align}
Double-precision variables have a precision of approximately 16 decimal digits. To keep a significance of (for example) $10^{-6}$ in the final result, we need to keep the maximum value below $10^{15} \times 10^{-6} = 10^{9}$.  From this, we can estimate the maximum layer thickness $h$:
\begin{align}
\textrm{Maximum Value} &= 10^9 = \left|  e^{i \beta^{(M)}_{(\pm N)} h}  \right|
\end{align}
There should always be sufficient orders to ensure that the highest outside orders are evanescent, so $\beta^{(M)}_{(+N)}$ should always be fully imaginary. Therefore,
\begin{align}
h &\approx \frac{\ln(10^9)}{ \operatorname{Im} \left(\beta^{(M)}_{N}\right) }
\end{align}
Experimentation has shown that using a layer thickness of approximately $h/2$ gives a reliable margin of stability.  

The two stability controls -- the integration error tolerance and the layer thickness -- are related. Thicker layers can sometimes become stable when the integration tolerance is decreased, but only to a limit; increasing the number of S-matrix layers is always the most reliable way to achieve stability.

\subsection{Obtaining and running the new software}
Work is still ongoing on a new web-based graphical user interface.  However, the command-line version of the program is ready for use, and can be downloaded and run following the instructions on the project repository:
\begin{center}
\begin{tabular}{rl}
\toprule
\textbf{Instructions and introduction:} & \url{https://github.com/markboots/peg}\\
\textbf{Download:} &\url{https://github.com/markboots/peg/zipball/master}\\
\textbf{Check out with git:}& \url{git://github.com/markboots/peg.git}\\
\textbf{Revision history:}& \url{https://github.com/markboots/peg/commits/master}\\
\bottomrule
\end{tabular}
\end{center}

The program accepts input via command-line arguments, and writes efficiency results to an output file. It can optionally update a progress file while the calculations are running; this allows other processes (such as a graphical front-end or web interface) to monitor the status of the run, check for failures, and see what fraction of the total calculations are finished. Table \ref{pegInput} documents the command-line arguments for specifying the grating and incidence configuration.  An example of the output file format is shown in Figure \ref{pegOutput}.

\renewcommand{\arraystretch}{1.0}
\begin{table}[htbp]
   \centering
   \topcaption{Input Specification (Command-line Arguments) for the \texttt{pegSerial} and \texttt{pegMPI} programs. } % requires the topcapt package
   {\small
   \begin{tabular}{@{} p{3cm}p{12cm} @{}} % Column formatting, @{} suppresses leading/trailing space
      \toprule
\multicolumn{2}{c}{\textbf{Required}}\\
\midrule
\midrule
\multicolumn{2}{l}{\textbf{Grating Specification:}}\\
\midrule
\texttt{--gratingType} & One of: [\texttt{rectangular blazed sinusoidal trapezoidal}]\\
\texttt{--gratingPeriod} & [grating period in um]\\
\texttt{--gratingGeometry} & [command-delimited list of geometry parameters, in um and/or degrees]\\
	&Rectangular profile: depth,valley width\\
	&Blazed profile: blaze angle,anti-blaze angle\\
	&Sinusoidal profile: depth\\
	&Trapezoial profile: depth,valley width,blaze angle,anti-blaze angle\\

\texttt{--gratingMaterial} & [grating substrate material]: 
	This should be a name corresponding to a refractive index database filename, e.g., Au, Ni, C, SiO2, etc.\\
	
\texttt{--N} & [truncation index]: 
	Specifies the number of positive and negative orders to include in the Fourier expansion. Will also determine the number of orders that are calculated, although if you only want to calculate 3 orders, you will still need a much larger truncation index for accurate results.  In the soft X-ray range, convergence is usually attained with $N \sim [15...45]$.\\

\\
\multicolumn{2}{l}{\textbf{Operating Mode:}}\\
\midrule

\texttt{--mode} & One of: [\texttt{constantIncidence} \texttt{constantIncludedAngle} \texttt{constantWavelength}] \\
\texttt{--min} & [min]\\
\texttt{--max} & [max]\\
\texttt{--increment} & [increment]\\
\\
\multicolumn{2}{l}{{Required, depending on the mode:}}\\ 
\\
\texttt{--incidenceAngle} &[incidence angle in degrees]  \\
\texttt{--includedAngle} &[deviation angle in degrees]\\
\texttt{--toOrder} &[diffraction order for the included angle] \\
\texttt{--wavelength} &[wavelength in um]\\

\\

&	In constant incidence mode, a calculation is performed for wavelengths from \texttt{--min} to \texttt{--max} in steps of \texttt{--increment}, at a fixed incidence angle given by \texttt{--incidenceAngle}.\\
&	In constant included angle mode, the incidence angle is calculated at each wavelength to ensure a constant included angle of \texttt{--includedAngle} between the incident light and the order specified in \texttt{--toOrder}. This is the operating mode for many monochromators. (Inside orders are negative, outside orders are positive.)\\
&	In constant wavelength mode, a calculation is performed for incidence angles from \texttt{--min} to \texttt{--max} in steps of \texttt{--increment}, for a fixed wavelength given by \texttt{--wavelength}.\\
	\\

\\
\multicolumn{2}{l}{\textbf{Output:}}\\
\midrule
\texttt{--outputFile} &[file name]:
	The calculation output will be written to this file.\\

\\
\\
\multicolumn{2}{c}{\textbf{\textbf{Optional}}}\\
\midrule
\midrule

\texttt{--progressFile} & [file name]:
	If provided, the current status of the calculation will be written in this file; it can be monitored to determine the progress of long calculations.  This provides an interface for other processes to monitor the status of this calculation (for example, a web-based or GUI front-end, etc.).\\
	
\texttt{--eV} &
	If this flag is included, all wavelength inputs (--min, --max, --increment, and --wavelength) will instead be interpreted as photon energies in electron volts (eV).\\
	
\texttt{--printDebugOutput} &
	If this flag is included, each calculation will print intermediate results to standard output.\\
        \bottomrule
   \end{tabular}
   }
   \label{pegInput}
\end{table}

\begin{table}[htbp]
   \centering
   \topcaption[Output file format for the \texttt{pegSerial} and \texttt{pegMPI} programs.]{Output file format for the \texttt{pegSerial} and \texttt{pegMPI} programs.  The Input section restates the program input, the Progress section is updated as the calculation completes, and each row of the Output section lists the independent variable (wavelength, eV, or incidence angle, depending on the mode) followed by the calculated efficiencies for all orders from $-N$ to $N$.\\~\\  {\footnotesize Test executed with: \texttt{./pegSerial --mode constantIncidence --min 100 --max 120 --increment 5 --eV --incidenceAngle 88 --gratingType blazed --gratingPeriod 1 --gratingMaterial Au --N 15 --gratingGeometry 2.5,30 --outputFile testOutput.txt --progressFile testProgress.txt}} } % requires the topcapt package
\begin{lstlisting}[frame=single,numberstyle=\small]
# Input
mode=constantIncidence
incidenceAngle=88
units=eV
min=100
max=120
increment=5
gratingType=blazed
gratingPeriod=1
gratingGeometry=2.5,30
gratingMaterial=Au
coatingMaterial=[none]
coatingThickness=0
N=15
integrationTolerance=1e-05
# Progress
status=succeeded
completedSteps=5
totalSteps=5
# Output
100	4.86049e-06,5.73524e-06,1.15331e-05,2.26984e-05,3.40043e-05,3.20538e-05,1.09471e-05,2.46656e-05,0.000207617,0.000525489,0.000402885,9.29454e-05,0.00604008,0.0202516,0.193704,0.688149, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
105	5.17974e-06,4.87572e-06,8.75638e-06,1.96591e-05,3.6063e-05,4.48567e-05,2.63319e-05,8.62826e-06,0.000156884,0.000572518,0.000629053,6.95573e-06,0.00581251,0.0252621,0.200502,0.678858, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
110	5.85305e-06,4.91785e-06,6.66783e-06,1.53924e-05,3.35836e-05,5.23866e-05,4.57548e-05,9.18712e-06,9.75067e-05,0.000564861,0.000862771,2.38342e-05,0.00534777,0.0305067,0.205757,0.669051, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
115	6.70782e-06,5.76303e-06,5.81191e-06,1.15465e-05,2.8753e-05,5.44993e-05,6.33855e-05,2.451e-05,4.82133e-05,0.000510943,0.00107579,0.000154448,0.00472995,0.0359483,0.209988,0.658912, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
120	7.51931e-06,7.11245e-06,6.20636e-06,8.89412e-06,2.30516e-05,5.20039e-05,7.60472e-05,4.85705e-05,1.87322e-05,0.000421879,0.00124637,0.000396847,0.00401002,0.0415518,0.213464,0.648892, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
\end{lstlisting}
   \label{pegOutput}
\end{table}
\renewcommand{\arraystretch}{1.2}

\subsection{Parallel program design and performance}
Over the past forty years, the power and speed of scientific software has increased exponentially.  Part of this has been the result of improved algorithms in numerical analysis, but most of it has come from a similar exponential increase in the processor speed and memory capacity of computer hardware.  Recently, however, physical limits have started to encroach on ``Moore's Law'', which originally suggested a doubling in chip performance every 18 months: as transistors approach the atomic scale, quantum effects will set a hard lower limit on their size.  In the future, software will no longer be able to count on perpetually-increasing processor speeds; instead, the only path to higher performance will come from exploiting \emph{parallelism}: the ability to compute parts of the problem simultaneously on multiple processors.  (This is already evident in the hardware trend of the past 4 years, where computer processor clock speeds have nearly stagnated, but the average number of cores per processor has increased from one to four.)  

For the present, parallel processing can provide a solution in two scenarios: when a numerical problem is too big to fit in a single computer's memory, or when the problem takes too long to run.  In our case, optimization and fitting tasks fall into the second category.  If we assume that \texttt{\textbf{Gradif}} is already implementing the differential method efficiently, then the \emph{only} way to beat its performance on the same hardware is by using parallelism.\footnote{In fact, because our software's variable step size integration method requires more calculations of the grating expansion $k_n^2$ in exchange for better stability, we should expect it to be slower than \texttt{\textbf{Gradif}} \emph{unless} we find a way to exploit parallelism.}

For both of these reasons, we designed the new software to support parallel calculations from the start.
\subsubsection{Fine-grained Parallelization}
\label{fineGrained}
Computing the grating efficiency in all orders $n$ at a single wavelength $\lambda$ can be viewed as a single ``calculation'' of the efficiency function:
\begin{eqnarray}
e_n = \textrm{eff}(\lambda, p_1, p_2, \ldots),
\end{eqnarray}
where the parameters $p_1, p_2, \ldots$ represent the grating parameters.  

Based on our experience with \texttt{\textbf{Gradif}}, we expect that this calculation can take from two seconds up to several minutes depending on the grating.  \textbf{Fine-grained parallelization} attempts to speed up a single calculation, which should benefit desktop users with multi-core processors.  By analyzing the differential method, we identified the following possibilities for decomposing the problem into parallel tasks:
\begin{itemize}
\item \textbf{Option 1}: In the shooting method, all of the $P=2(2N+1)$ trial solutions need to be numerically integrated from $y_{m-1}$ to $y_m$ in each slice.  All of the trial solutions are independent, allowing parallelization of this process over $p$.  Profiling results (Table \ref{timing}) show that the integration process, including calculation of the permittivity matrix $M(y)$ at each  step, represents 99.99\% of the total calculation time. This suggests that this is the (only) worthwhile candidate for parallelization.  When using the S-matrix method, if there are more processors available than trial solutions $P$, we can also parallelize the independent integrations over each layer $m$.
\item \textbf{Option 2}: The permittivity matrix $M(y)$ must be calculated based on the grating profile, for each grid value along the $y-$axis.  If the integration routine uses a fixed step size, the computation of all the $M$ matrices could be parallelized over grid points.  This is not directly possible if the integration routine uses a variable step size, in which case $M$ needs to be evaluated at each integration step.
\item \textbf{Option 3}: The final step of the shooting method requires inversion of a $2N+1$ linear algebraic system; this could optionally use a parallel iterative solver, but for typical $N$ values from 15 to 45, there is little room for improvement here: the matrix calculations are already small, fast, and fit easily within a single processor's memory space.  With $N=15$, they account for less than 0.02\% of the total run time of the serial program (Table \ref{timing}).
\end{itemize}

\begin{table}[htbp]
   \begin{center}
\topcaption[Time profile measurements of solver operations, averaged over 5 runs in single-threaded mode.]{Time profile measurements of solver operations, averaged over 5 runs in single-threaded mode.  Essentially all of the time is spent in the integration of the trial solutions, which includes the required calculation of $M(y)$ at each integration step.  This example is for a blazed grating, using $N=15$.  \\~\\  {\footnotesize Test executed with: \texttt{./pegSerial --mode constantIncidence --min 100 --max 120 --increment 5 --eV --incidenceAngle 88 --gratingType blazed --gratingPeriod 1 --gratingMaterial Au --N 15 --gratingGeometry 2.5,30 --outputFile testOutput.txt --progressFile testProgress.txt --measureTiming}} }
   \begin{tabular}{@{} lr @{}} % Column formatting, @{} suppresses leading/trailing space
      \toprule
	Solver Operation & Percent of Run time\\
      \midrule
   Allocate Memory	&	0.0003\%	\\   Look up refractive index	&	0.6803\%	\\   Compute $\alpha_n$, $\beta_n$ values and layers	&	0.0006\%	\\   Numerically integrate trial solutions	&	99.3011\%	\\   S-matrix operations	&	0.0174\%	\\   Compute Rayleigh coefficients $B^{(M)}_n$	&	0.0003\%	\\   Compute and package efficiencies	&	0.0001\%	\\
      \bottomrule
   \end{tabular}
   \label{timing}
 \end{center}
\end{table}

\subsubsection{Coarse-grained Parallelization}
Fine-grained parallelization over trial solutions has a limit to scaling: it can only use up to $P\times(M-1)$ processors, if we distribute every trial integration within every layer.  (This is obviously not a practical limit for desktop users with four or eight cores, but it does limit the theoretical scalability of the program in a high-performance computing (HPC) facility.)  However, all three of the use-cases -- efficiency curves, optimization, and fitting -- require repeated calculations of the efficiency function over different wavelengths or parameters.  Because all of these calculations can be done independently, we can obtain a nearly linear speedup using an ``embarrassingly parallel'' distribution of separate calculations to each processor.  This avoids nearly all the overhead of synchronization and communication that can limit parallel performance.  Due to the small amount of information that needs to be shared across processes, this approach could scale to effectively use hundreds or thousands of nodes in a HPC facility.

\subsubsection{Parallel Implementation Details}
The fine-grained approach requires substantially more inter-process communication than the coarse-grained approach.  Therefore, we implemented it using the shared-memory programming paradigm using the OpenMP library \cite{openmp08}.  Based on the profiling results (Table \ref{timing}), we determined that any performance gained from Option 3 would not be significant enough to make it worth attempting.  Because we chose an adaptive step-size integration algorithm to increase the integration stability, Option 2 was not possible, so we concentrated on implementing parallelization over trial solutions (Option 1).

Fine-grained parallelization is built into the \texttt{pegSerial} program, and enabled using the \texttt{--threads} command-line argument.  We tested the parallel efficiency of this mode using one of the machines in the \texttt{bugaboo.westgrid.ca} cluster, part of the WestGrid high-performance computing resource that is made available to academic researchers through Compute Canada.  On this machine, we could use up to 12 processors; the results in Table \ref{tableOpenMPTiming} show that our code achieves a parallel utilization efficiency of 94\% using 4 threads, dropping to 81\% as the overhead increases with 12 threads.

\begin{table}[htbp]
\begin{center}
\topcaption[The run time, speedup, and efficiency attained using OpenMP fine-grained parallelization on a single \texttt{bugaboo} node using up to 12 processors. ]{The run time, speedup, and efficiency attained using OpenMP fine-grained parallelization on a single \texttt{bugaboo} node using up to 12 processors. Reported results are based on the minimum run time of five runs.\\~\\ Test format: \texttt{./pegSerial --mode constantIncidence --min 100 --max 131 --increment 1 --incidenceAngle 88 --outputFile timingTestOutput.txt --gratingType blazed --gratingPeriod 1 --gratingMaterial Au --N 15 --gratingGeometry 2.5,30 --eV --threads} $t$} % requires the n topcapt package
\begin{tabular}{@{} lccccccc @{}} % Column formatting, @{} suppresses leading/trailing space
\toprule
Threads $t$:	&	1	&	2	&	4	&	6	&	8	&	10	&	12	\\
\midruleRuntime (s):	&	94.55	&	48.50	&	25.27	&	17.80	&	13.35	&	11.33	&	9.71	\\Speedup:	&	1	&	1.95	&	3.74	&	5.31	&	7.08	&	8.35	&	9.73	\\Efficiency:	&	100\%	&	97\%	&	94\%	&	89\%	&	89\%	&	83\%	&	81\%	\\
\bottomrule
\end{tabular}
\label{tableOpenMPTiming}
\end{center}
\end{table}

The coarse-grained parallelization lends itself naturally to a distributed-memory computing paradigm, so we implemented it using the Message Passing Interface (MPI) standard \cite{mpi08}.  In this environment, the same program (\texttt{pegMPI}) is launched simultaneously on multiple processors in a cluster computer.  Each program determines for itself which wavelengths/energies/incidence angles it should calculate.  After every calculation, each program broadcasts its results over the network to the ``root node'', which is responsible for writing a single output file and progress file.

Table \ref{tableMPITiming} shows that the coarse-grained parallelization is extremely efficient; in fact, it seems to run more efficiently than the single-threaded program.  This is of course impossible; the efficiencies over 100\% are timing artifacts caused by the fact that some \texttt{bugaboo} nodes are faster than others.  

\begin{table}[htbp]
\begin{center}
\topcaption[The run time, speedup, and efficiency attained using MPI coarse-grained parallelization on the \texttt{bugaboo} cluster using 1 to 32 processors.]{The run time, speedup, and efficiency attained using MPI coarse-grained parallelization on the \texttt{bugaboo} cluster using 1 to 32 processors.  Reported results are based on the minimum run time of five runs.  The efficiencies larger than 100\% are measurement artifacts, due to some \texttt{bugaboo} nodes being faster than others; there is no way for the \texttt{pegMPI} program to exceed a theoretical efficiency of 100\%.\\~\\ Test format: \texttt{mpiexec -n $P$ ./pegMPI --mode constantIncidence --min 100 --max 131 --increment 1 --incidenceAngle 88 --outputFile timingTestOutput.txt --gratingType blazed --gratingPeriod 1 --gratingMaterial Au --N 15 --gratingGeometry 2.5,30 --eV}} % requires the n topcapt package
\begin{tabular}{@{} lccccccc @{}} % Column formatting, @{} suppresses leading/trailing space
\toprule
Processors $P$:	&	1	&	2	&	4	&	8	&	16	&	32	\\
\midruleRuntime (s):	&	112.73	&	54.33	&	27.14	&	13.64	&	6.37	&	3.23	\\Speedup:	&	1	&	2.07	&	4.15	&	8.27	&	17.70	&	34.91	\\Efficiency:	&	100\%	&	104\%	&	104\%	&	103\%	&	111\%	&	109\%	\\
\bottomrule
\end{tabular}
\label{tableMPITiming}
\end{center}
\end{table}

Modern cluster architectures often contain many independent computers (``nodes'') connected via a local area network, with every node having four to eight local processor cores.  To take advantage of this architecture, the two parallel modes can be used simultaneously in a hybrid execution model using fine-grained distribution over the local processor cores, and coarse distribution over cluster nodes.

\subsection{Validation of the new software}
We tested the new software extensively for logical self-consistency, and for consistency with \texttt{Gradif}.  In this section, we list examples of the tests that gave us confidence that its output is physically reasonable; in the next chapter, we validate both \texttt{Gradif} and our new software against experimental measurements.

\subsubsection{Physical Principles}
\begin{itemize}
\item \textbf{Conservation of Energy} requires that the sum of transmitted and reflected efficiencies must be unity for lossless (non-absorbing gratings), and always less than unity for absorbing gratings.  If we set the imaginary component of the refractive index to 0, we can confirm that the sum of all reflected and transmitted efficiencies is exactly 1.0:
\begin{itemize}
\item Example triangular grating: 1000 lines/mm, 2.5\dg blaze angle, 88\dg incidence angle, 410 eV, $N=15$:
\begin{itemize}
\item With refractive index $\nu_1 = (1.4 + 0i)$, the efficiency sum is $\sum e_{r,n} + \sum e_{t,n} = 0.703347 + 0.296606 =$ \textbf{0.999953}.
\item With refractive index $\nu_1 = (0.993 + 0i)$, the efficiency sum is $\sum e_{r,n} + \sum e_{t,n} = 0.983451 + 0.016549 =$ \textbf{0.999999}.
\end{itemize}
\end{itemize}
Real gratings are absorbing materials, such as Platinum at 410 eV:
\begin{itemize}
\item With refractive index $\nu_1 = (0.993 + 0.00754i)$, the efficiency sum is $\sum e_{r,n} + \sum e_{t,n} = 0.45904 + 0.000782219 =$ \textbf{0.459822}.
\end{itemize}
\item The \textbf{Reciprocity Theorem} requires that the intensity of an electromagnetic signal should not change when swapping the source and the detector. For gratings, this would represent an exchange of the incident plane wave and the outgoing diffraction order of interest.  Surprisingly, this means that the efficiency of order $n$ at an incidence angle $\theta_2$ should be the same as the efficiency of the corresponding order at incidence angle $\theta_2' = -\theta_{2,n}$.
\begin{itemize}
\item Example triangular grating: 1000 lines/mm, 2.5\dg blaze angle, 30\dg anti-blaze angle, 410 eV, $N=15$:
\begin{itemize}
\item At $\theta_2 = 88\deg$ incidence, the calculated $(-1)$ order efficiency is \textbf{8.23519\%}.  The outgoing angle is $\theta_{2,-1}=85.114\deg$.
\item At $\theta'_2 = -85.114\deg$ incidence, the calculated $(-1)$ order efficiency is \textbf{8.23339\%}.   (The outgoing angle is $-88\deg$ as required.)
\end{itemize}
For another test, instead of using a negative incidence angle, we mirrored the grating geometry horizontally and extracted the outside order instead:
\begin{itemize}
\item At $\theta''_2 = 85.114\deg$ with a 30\dg blaze angle and 2.5\dg anti-blaze angle, the calculated  $(+1)$ order efficiency is \textbf{8.23339\%}.
\end{itemize}
\end{itemize}
One consequence of the reciprocity theorem is that the $0^\textrm{th}$ order reflection efficiency should not change when rotating a grating around its $y$-axis by 180\dg.  Although this might be obvious for symmetric gratings, it is rather surprising for gratings with asymmetric groove profiles.  For example, the $0^\textrm{th}$ order efficiency for the 2.5\dg blazed grating calculated above was \textbf{18.1245\%} at 88\dg incidence.  Flipping the grating to obtain a 30\dg blaze angle and 2.5\dg anti-blaze angle, we calculated an identical $0^\textrm{th}$ order efficiency of \textbf{18.1245\%}.
\end{itemize}

\subsubsection{Logical consistency for coatings}
When the software was extended to handle coatings, there were several opportunities to check for logical situations where the efficiencies should remain the same.  Because the coating amounts to a vertical extension of the grating profile, a coating of material X on top of a substrate of the same material should represent the same physical grating -- despite being calculated differently.  If we know the efficiency of a bare grating of material X, all of the following coating scenarios should (and do!) produce the exact same results, albeit with longer calculation times:
\begin{itemize}
\item A 0-thickness coating of any material Y on X
\item A thin (interpenetrating) coating of material X on X
\item A thick coating of material X on X
\item A very thick coating of material X on any material Y
\end{itemize}

\subsubsection{Logical consistency for S-matrix layers}
When the software was extended to use the S-matrix algorithm, we expected that:
\begin{itemize}
\item For thin gratings that were previously stable, it should reproduce the same results as the basic shooting method (Section \ref{shootingMethodDescription}).
\item For thick gratings that were previously unstable, it should produce stable results.
\item For gratings that previously showed wavelength regions of stability and instability, the new results should converge with the previous regions of stability.
\item As long as sufficient layers are used, the results should be invariant to the number of layers.
\end{itemize}
All of these criteria are satisfied.  For thin gratings, the results using 1, 2, 5, 10, and 100 layers are identical to more than six significant figures.  Figure \ref{SMatrixStability} shows a great example of a problem that was unstable at high energies when using a single layer; using just a few layers, the S-matrix approach eliminates these instabilities but converges smoothly with the valid parts of the original curve.

\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
   \centering
   \includegraphics[scale=0.8]{Extended/SMatrixStability/SMatrixStability.pdf} 
   \caption[The S-matrix approach is the solution for this problem that becomes unstable at high energies when using the basic shooting method.]{The S-matrix approach is the solution for this problem that became unstable at high energies when using the basic shooting method.  The software automatically determines the number of layers required, ranging here from one layer at low energies to three layers at high energies.  The inset in the $3^\textrm{rd}$-order curve shows that the numerical error ``noise'' is also reduced, even for calculations that remain ``stable''.  (Blazed grating, 600 lines/mm, 1.85\dg blaze angle, gold substrate, 86\dg incidence.)}
   \label{SMatrixStability}
\end{figure}

\subsubsection{Logical equivalence for point-wise defined profiles}
When the software was extended to handle arbitrary groove shapes based on a set of $(x,y)$ points defining the surface function $y_p = g(x)$, we confirmed that although the method for calculating the $k^2_n$ expansion differs, we produced the same results for the basic profiles (rectangular, blazed, and trapezoidal) and their point-wise defined equivalents.

\subsubsection{Comparison to \texttt{Gradif}}
We compared the new software to previous \texttt{Gradif} calculations of the TE efficiency for a wide range of gratings.  We found that both programs are in agreement, typically to at least three significant figures.  (The exact agreement depends on the number of integration steps chosen for \texttt{Gradif}; increasing the number of steps generally improves the agreement.)  Figure \ref{pegVsGradif} shows a set of comparison calculations over a range of coating thicknesses.  The red curve shows the relative difference in the efficiencies calculated by the two programs for the 50 nm-thick grating; it is less than 1000 parts per million everywhere.  For all practical purposes, the results are identical.  Work is ongoing to examine whether the new software can handle calculations that previously fell outside \texttt{Gradif's} domain of convergence.

\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
   \centering
   \includegraphics[scale=0.8]{Chapter3/3f_coatingThickness/pegVsGradif.pdf} 
   \caption[Shown over a range of coating thicknesses, the new software agrees with \texttt{Gradif} results to more than three significant figures.]{The new software agrees with \texttt{Gradif} to more than three significant figures.  These calculations show the TE efficiency for a blazed grating on an SiO$_2$ substrate, with a range Pt coating thicknesses.  The red curve is the relative difference between the two programs for the 50 nm calculation, in parts per million.  (Blazed grating, 1200 lines/mm, 1.46\dg blaze angle, 88\dg incidence.)}
   \label{pegVsGradif}
\end{figure}

