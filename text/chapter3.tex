\chapter{Implementation of Theory: What people and I did to implement the theory using computers}

In the initial stages of the spectrometer design project, we used \texttt{\textbf{Gradif}} -- a program written by one of the original authors of the differential theory -- for all of our calculations and optimizations.  We also built a user interface for this program, to speed up the process of entering input and running multiple calculations.  More recently, we implemented a new, open-source grating efficiency calculator from scratch to address some shortcomings of the \texttt{\textbf{Gradif}} code: performance, stability, and the ability to handle arbitrary grating shapes.  A secondary benefit of this last project is the opportunity to share it freely with the grating/beamline design community, and to extend it in conjunction with other researchers.

In this chapter, we examine the existing grating software options, describe our experience using the \texttt{\textbf{Gradif}} code, and review the development and validation of new grating efficiency software.

\section{Pre-existing grating efficiency software}
Currently there are four commercial or closed-source programs available for calculating diffraction grating efficiencies (Table \ref{commercialComparison}).  \texttt{\textbf{PCGrate}} implements the modified integral method \cite{Gor02} and is the most general, although also the slowest and most expensive.  \texttt{\textbf{GSolver}} uses the Rigorous Coupled Wave approximation \cite{Moh82}\cite{Moh86} and can therefore handle any grating shape, subject to the previously noted issues with the staircase approximation in TM polarization.  Two implementations of the differential method are available: Professor Neviere sells an implementation called \texttt{\textbf{Gradif}}, and the \texttt{\textbf{REFLEC}} program is used internally at the BESSY synchrotron.  Although the differential method is general, both of these implementations are limited to predefined grating profiles (rectangular, blazed, trapezoidal, and sinusoidal).

Table \ref{commercialComparison} compares the features, cost, and performance of these programs.

\renewcommand{\arraystretch}{1.8}
\begin{table}
\topcaption{Comparison of commercially-available grating efficiency software}
{\footnotesize
\begin{tabularx}{\textwidth}{@{} p{1.7in}p{1in}p{0.8in}XXX @{}}
\toprule
        Name and Organization                                                        & Method                         & Price (USD)                                            & Graphical User Interface & Arbitrary Shapes        & Comparative Run Time \\ \midrule
        \textbf{PCGrate-SX 6.5}\newline IIG, Inc.\newline http://www.pcgrate.com & Modified Integral Method (MIM) & GUI: 15749\newline Console: 11249\newline Both: 22499 & Available                & Yes                     & ~                    \\ 

        \textbf{GSolver 5.2} \newline Grating Solver Development Co. \newline http://www.gsolver.com            & Rigorous Coupled Wave (RCW)    & 795                                                    & Yes                      & Yes & ~                    \\  
        \textbf{Gradif}\newline Dr. Michel Neviere \newline m.neviere@free.fr                                                    & Differential Method            & 6090                                                   & No                       & No                      & ~                    \\ 
        \textbf{REFLEC}\newline Dr. Michael Krumrey\newline Michael.Krumrey@ptb.de                 & Differential Method            & 0                                                      & No                       & No                      & ~    \\
\bottomrule
   \end{tabularx}
}
\label{commercialComparison}
\end{table}
\renewcommand{\arraystretch}{1.2}


\section{Improving the usability and efficiency of Gradif}
The Canadian Light Source purchased the \texttt{\textbf{Gradif}} code and made it available for this project.  However, there were two challenges involved in applying the code:
\begin{enumerate}
\item The code itself is a Fortran-language program that provides no user interface.  Instead, to calculate an efficiency data point for a grating at just one energy, approximately 30 numbers must be entered into a blank screen, with no prompts, in the correct order.  These numbers define the grating geometry, the coating/layer thicknesses, the incidence conditions, the integration parameters, and also the complex refractive indices of the layers and the substrate.\footnote{These last two values will change as a function of photon energy, since the refractive index varies with wavelength, so we need to look them up for each data point.}  Using this program requires a time-consuming and error-prone data entry process.
\item In the event of an error made during data entry, one of many grating parameters could end up outside the narrow region of convergence where the code is able to  numerically integrate a solution successfully.  When this happens, the program runs forever in an infinite loop, with no feedback that the calculation has failed.  This region of convergence is not well established, so even when data entry errors are avoided, it is possible for a user to specify a valid grating that is -- for example -- too deep to be calculated.  Without user feedback, it is impossible to know if the calculation is still running successfully, or if it has failed into this infinite loop.
\end{enumerate}
To beat these two challenges, we built a web-based graphical interface, and carefully modified the Fortran source code to detect convergence failures.
\subsection{Visual interface to the \texttt{\textbf{Gradif}} code}
Figure \ref{3b} shows a screenshot of the graphical user interface (GUI) that we built to help us perform efficiency calculations efficiently.  The interface served as a wrapper to generate input for the \texttt{\textbf{Gradif}} code, manage running a set of calculations, and extract the results.

\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
   \centering
   \includegraphics[scale=0.6]{Chapter3/3b_nephiere/3b_1.pdf} \\
%\vspace*{0.25in}
   \includegraphics[scale=0.6]{Chapter3/3b_nephiere/3b_2.pdf}
   \caption{This web application provides a graphical user interface for calculating grating efficiencies. Forms prompt users for the grating parameters.}
   \label{3b}
\end{figure}

The interface was implemented as a web-based application, so it could be used from anywhere through a browser, without having to distribute the Gradif code or install anything on a person's individual computer.  Users described the grating parameters and incidence scenario through a form that prompted them for the necessary information based on the type of grating (Figure \ref{3b}).  When the calculation finished, an efficiency plot would be generated, and users could also download data tables of their calculations.  These tables were also archived so they could be retrieved later.

It supported the following features:
\begin{itemize}
\item \textbf{Grating types}\\
The form would request the geometry parameters required for each of the supported grating types: rectangular, blazed, trapezoidal, and sinusoidal profiles.

\item \textbf{Order and polarization}\\
Users could configure which inside and outside orders were plotted, and specify the polarization of the incident light: TE, TM, or natural light (randomly polarized).

\item \textbf{VLS gratings}\\
To model variable line space (VLS) gratings, the interface accepted the VLS parameters in conventional notation (linear, quadratic, and cubic corrections) and used these to calculate the groove density and corresponding efficiency at a user-determined number of points along the grating surface; the overall efficiency was taken as an average of these.

\item \textbf{Efficiency plots as a function of wavelength}\\
In the simplest mode, the system generated a plot of the efficiency in the desired orders as a function of wavelength, holding all the other parameters constant (Figure \ref{3b_3}).  This would represent the typical case of testing how a grating would perform in a beamline.

\begin{figure}[p] %  figure placement: here, top, bottom, or page
   \centering
   \vspace*{-.5in}
   \includegraphics[scale=0.6]{Chapter3/3b_nephiere/3b_3.pdf} \\
%\vspace*{0.25in}
   \includegraphics[scale=0.6]{Chapter3/3b_nephiere/3b_4.pdf}
   \caption{This web application provides a graphical user interface for calculating grating efficiencies. The results are plotted, and users can download a text-based table for further analysis.}
   \label{3b_3}
\end{figure}

\item \textbf{Complex scans over arbitrary grating parameters}\\
The interface also offered flexibility to test arbitrary relationships along incidence angle, energy, geometry, and other parameters. This feature was most efficiently used in conjunction with a spreadsheet or other data analysis program to fill in the grating parameters and interpret the output tables.

\item \textbf{Database of optical materials and refractive index}\\
We also developed a database of common grating substrate and coating materials, so that the interface could automatically look up their complex refractive index as a function of photon energy.  This information was calculated using the semi-empirical Henke data tables of the x-ray atomic scattering factor \cite{Hen93} discussed in Section \ref{secHenke}.  The library is valid from 30 eV to 10~000 eV, but is known to have poor accuracy in the vicinity of absorption edges.

\item \textbf{Mirror reflectivity}\\
As an additional tool for beamline designers, we implemented the ability to calculate the reflectivity of a simple mirror using any of the materials in the refractive index database.  Mirror reflectivity was computed as a function of incidence angle and photon energy using the complex Fresnel equations \cite[p. 40]{Fow89} for both polarizations.

\item \textbf{Control of numerical precision}\\
An `Options' page (Figure \ref{3b_5}) allowed users to configure the numerical precision used in the calculations.  The two critical factors are the number of integration steps used in the numerical integration of the particular solutions for the $A_n^{(m)}$ and $B_n^{(m)}$ coefficients at each layer, and the number of Fourier coefficients $2N+1$ used in the truncated sum.  The defaults we chose ($N=31$; 401 integration steps) were found to produce accurate results and reasonable performance across the entire soft x-ray range, as long as the coating thickness was less than 0.5um.   However, prudent designers should still do convergence tests for any high-stakes results, by repeating the calculations and comparing against efficiencies computed using larger values.  This technique can also be used to find the minimum number of Fourier coefficients that are required before the results start to disagree.  (This can be helpful to optimize the computation speed before running a large number of calculations on similar gratings at similar wavelengths.)
\end{itemize}

\begin{figure}[p] %  figure placement: here, top, bottom, or page
   \centering
   \includegraphics[scale=0.6]{Chapter3/3b_nephiere/3b_5.pdf}
   \caption{This `Options' page configures the numerical precision of the calculations, the diffraction orders of interest, and the polarization of the incident light.  It also sets some other house-keeping options for where users want to store their data.}
   \label{3b_5}
\end{figure}

\subsection{Detecting integration failures}
When an integration fails, the original \texttt{\textbf{Gradif}} code is programmed to repeatedly retry the calculation using successively thinner S-matrix layers.  Sometimes this strategy is successful, but in many cases the integration fails regardless of the layer thickness, leading to an infinite loop.  
The Fortran code was written using a 1970's-era programming approach, including substantial use of global variables and GOTO statements.  (These two features are heavily discouraged in modern programming methodologies.)  As a result, the code is hard to trace, but we were able to insert a counter to detect when a numerical integration fails after many repeated attempts.  Our modification allows the calculation to exit with an error message, rather than run indefinitely.

\subsection{Online access}
%Since we released the user interface under an `open-source' license, it can be upgraded or enhanced by anyone with an interest in beamline design and grating efficiency.  Julian Miller, a summer student in the metrology department at the CLS, recently created an updated version of the interface to support multi-threaded calculations and add more options for incidence configurations.  To the original `constant incidence angle' mode, he added a `constant included angle' mode, used in many monochromators, which tilts the grating as a function of photon energy to maintain a constant angle between the incident and outgoing beam in the desired order.  Since every grating efficiency calculation (at a single energy) is independent, they can be run in parallel; this takes advantage of modern multi-core processors, and dramatically speeds up the creation of a user's plot or data set.  In the future, this could be extended even further to spread calculations over a cluster of computers, or on distributed hardware in a `cloud computing' network.
Because the user interface ran as a web application, it could be (and was) accessed by beamline designers from all over the world.  In one example, it was used by Professors Coryn Hague and Gheorghe Sorin Chiuzbaian to improve the design of a new beamline for the SOLEIL synchrotron (TODO ref).  The calculations could be requested by anyone from anywhere, but they all ran on a single server computer at the University of Saskatchewan.  Unfortunately, the underlying \texttt{\textbf{Gradif}} code is commercial software, and while we were licensed to run it on this machine, recent communication from Professor Neviere indicated that he was unhappy with this unpaid access to results calculated using his code.  As a result, we disabled public access to the original website.

\section{Improved, open-source grating efficiency software}
\subsection{Motivation for new grating software}
The \texttt{\textbf{Gradif}} code allowed us to complete the design and optimization of the REIXS spectrometer in Chapter 6; however, several limitations provided motivation for improvement:
\begin{enumerate}
\item \textbf{Unpredictable instability}: For some rare but reasonable grating inputs, the numerical integration process becomes unexpectedly unstable. We expect this to happen for deep gratings outside of Gradif's convergence range, but in other cases the failed calculations are surrounded by successful calculations. The random failures can usually be avoided by tweaking the number of integration steps or the number of Fourier coefficients, but not in a consistent or predictable way.
\item \textbf{Performance}: The run time of a single calculation depends on the grating depth, number of Fourier coefficients, and number of integration steps required for convergence; it can range from two seconds for shallow gratings to well over 30 seconds.  At this speed, it is feasible to calculate the efficiency of a single grating over a range of wavelengths; however, if we want to do global optimization or fitting (Chapter 7), faster run times are desired.  The Gradif code is inherently single-threaded, although independent calculations can be run simultaneously by invoking the program multiple times.
\item \textbf{Arbitrary groove profiles}: As we will see in Chapter 7, grating manufacturing rarely produces the perfect, intended groove profile.  To model real-world gratings, we need the ability to represent profiles of arbitrary shape; for example, point-wise defined curves derived from atomic force microscopy (AFM) measurements.
\item \textbf{Open online access}: Finally, since grating efficiency has rarely been considered during many past beamline designs, we believe the soft x-ray instrument design community would benefit from having access to an easy-to-use, easy-to-access grating efficiency calculator.  It became obvious after taking down the original web interface to Gradif that there was a strong demand for this service.
\end{enumerate}

These four factors motivated us to write a new implementation of the differential method from scratch.
\subsection{Features and limitations}
We envision two different software activities (``\emph{use-cases}'') that would be helpful during the design phase of a soft x-ray instrument:
\begin{enumerate}
\item \textbf{Producing efficiency curves}: For a potential grating specification, a designer might want to predict its efficiency over the range of wavelengths or photon energies where that grating would be used.  (For examples, see Figures \ref{4h-1}, \ref{4h-2}, and \ref{4h-3} in Chapter 6.)

These curves might assume a constant incident angle (for example, in a fixed-incidence spectrometer), or the designer might want to vary the incidence angle according to some function of the wavelength (for example, when designing a constant included angle (CIA) monochromator).
\item \textbf{Optimization}: Instead of simply predicting the efficiency, a designer probably wants to optimize it by varying the grating parameters within an acceptable range.  The grating parameters also affect the focussing and resolution characteristics of the instrument, therefore the designer will usually have constraints for some of the parameters. In other cases, they might wonder if a certain increase in efficiency is worth the trade-off it causes in resolution.

A global optimization method is desired here for two reasons: the efficiency function may have several local maxima, and the parameters have hidden dependencies.  (For example, we show in Section \ref{blazeAngle} that the optimal ``blaze angle'', or the angle at the base of a triangular groove profile, is highly coupled to the incident angle, order, groove width, and wavelength.)
\end{enumerate}

Finally, there is one computationally intensive use-case that would be valuable to grating manufacturers and theorists:

\begin{enumerate}[resume]
\item \textbf{Fitting grating parameters to measured efficiency}: To validate and improve any of the modelling methods, we need to actually measure the efficiency of real gratings.  This can be done on special beamlines that have been designed with \textbf{diffractometer} chambers for this purpose; we discuss our own measurements in Chapter 7.  Some of the real-world grating parameters are hard to measure; for example, we found that the micro-structure of the surface (oxidation and roughness) dramatically affects the efficiency, but it is difficult to measure the roughness and oxidation levels directly.  If these parameters could be incorporated into the efficiency model, a curve-fitting search could determine the parameters that best match the theoretical to the measured efficiency curves.
\end{enumerate}

We wrote the new grating software in modular components so that it could be applied to all three of these use-cases.  The grating solver (implementation of the differential method) is complete, along with an \emph{application programming interface} (API) to integrate the solver into third-party programs.  A command-line user interface enables single efficiency calculations or the calculation of efficiency curves in three different incidence modes.  Work continues toward a web-based user interface, and a built-in global optimization and fitting facility.  (Optimization and fitting can already be done using third-party tools, using the command-line interface or API to evaluate single efficiencies.)

\subsubsection{Features}
The solver and command-line interface support the following features:
\begin{itemize}
\item \textbf{Standard grating shape profiles}: rectangular, triangular, trapezoidal, and sinusoidal.
\item \textbf{Custom grating shape profiles}: any point-wise defined profile.
\item \textbf{Coatings}: an optional coating layer of a different material on top of the grating, generated by translating the grating profile vertically.  The coating can be thicker than the groove depth, leaving a homogeneous layer between the coating grooves and the grating grooves, or it can interpenetrate the grating grooves.
\begin{itemize}
\item Note: Coatings are not yet supported on custom profiles.
\end{itemize}
\item \textbf{Material Database}: automatic lookup of complex refractive indexes for common materials based on the Henke tables.
\item \textbf{Incidence scanning modes} when calculating efficiency curves:
\begin{itemize}
\item over wavelength, using a constant incidence angle, 
\item over wavelength, maintaining a constant included angle, and 
\item over incidence angle at a constant wavelength.
\end{itemize}
\item \textbf{Scalable parallel calculations}:
\begin{itemize}
\item fine parallelization of a single calculation
\item coarse parallelization of many efficiency points using grid computers.
\end{itemize}
\end{itemize}

\subsubsection{Limitations}
The current version has two main limitations; work is ongoing to remove both of these:
\begin{enumerate}
\item The solver currently only calculates the efficiency for TE polarization.  Since the TE and TM polarization efficiencies converge at grazing incidence, for soft x-ray optics used in grazing incidence there is very little difference between the TE and TM polarization.  Figure \ref{TODO} shows a grating at 88 degrees incidence calculated using the Gradif program; the difference between TE and TM efficiency is less than 2\% (relative) everywhere.  Therefore, designers currently using the TE results for optimization should not be misled even if their actual incidence configuration includes TM light; however, implementing the TM solver is necessary for completeness and accuracy at more normal incidence angles.
\item Interpenetrating coatings are not yet supported for custom (point-wise defined) groove profiles.
\end{enumerate}

\subsubsection{Improving Stability}
The solver uses two techniques to improve integration stability of the ordinary differential equation \eq{matrixDE}.  Gradif uses a fixed number of vertical integration steps, regardless of the height of the grating or the thickness of the S-matrix layers.  Therefore, the user needs to manually estimate the appropriate number of integration steps necessary for convergence of a specific problem.  Instead of a fixed step size, we use an adaptive step size integration algorithm with error prediction, to ensure that the error at every integration step remains under a defined tolerance.  This allows us to automatically use smaller steps where the problem is sensitive, and larger steps for faster performance whenever possible.  The user no longer needs to manually estimate the appropriate number of integration steps, although they can adjust the tolerance setting if required for exceptional problems.  (The default tolerance setting was determined over a range of typical soft x-ray grating inputs to offer good performance while ensuring convergence and a wide margin of stability.)  Although the variable step size method offers better accuracy, better reliability, and less possibility of operator error, it comes with one performance trade-off: we can no longer share computations of the $M(y)$ matrix and $k^2_n(y)$ expansions across all the trial solutions; each trial solution will potentially need to evaluate them at different values of $y$.

For the ODE integration algorithm, we experimented with a variety of explicit methods (classical 4th order Runge-Kutta, Runge-Kutta-Fehlberg, multistep Adams-Bashforth) and implicit methods (second and fourth-order Runge-Kutta, Bulirsch-Stoer, multi-step backward difference).   We found that the results were insensitive to the integration method to more than six significant figures, and that the explicit methods (predictably) ran much faster than the implicit ones.  Currently, we use a method under the family of \emph{Adams-Bashforth multistep methods}, which uses an explicit Adams-Bashforth predictor and an implicit Adams-Moulton corrector \cite{Byr75}. It was found to offer the highest performance, since the error estimation requires far fewer function evaluations than  the classical Runge-Kutta algorithm.

The solver's second stability improvement comes from automatically estimating the number of S-matrix layers required to keep the integration values bounded within significance.  The largest values of the exponential functions $[\exp(i \beta_n y)]$ occur for the largest orders $-N$ and $N$, where $\beta_{(\pm N)} \approx \pm i 2\pi N/d$.  To estimate the maximum size these will reach after integration over a layer of thickness $h$, we can bound them with an assumed homogeneous layer with the same index as the vacuum:
\begin{align}
\textrm{Maximum Value} &\approx \left|  e^{i \beta^{(M)}_{(\pm N)} h}  \right|
\end{align}
Double-precision variables have a precision of approximately 16 decimal digits. To keep a significance of (for example) $10^{-6}$ in the final result, we need to keep the maximum value below $10^{15} \times 10^{-6} = 10^{9}$.  From this, we can estimate the maximum layer thickness $h$:
\begin{align}
\textrm{Maximum Value} &= 10^9 = \left|  e^{i \beta^{(M)}_{(\pm N)} h}  \right|
\end{align}
There should always be sufficient orders to ensure that the highest outside orders are evanescent, so $\beta^{(M)}_{(+N)}$ should always be fully imaginary. Therefore,
\begin{align}
h &\approx \frac{\ln(10^9)}{ \operatorname{Im} \left(\beta^{(M)}_{N}\right) }
\end{align}
Experimentation has shown that using a layer thickness of approximately $h/2$ gives a reliable margin of stability.  

The two stability controls -- the integration error tolerance and the layer thickness -- are related. Thicker layers can sometimes become stable when the integration tolerance is decreased, but only to a limit; increasing the number of S-matrix layers is always the most reliable way to achieve stability.

\subsection{Obtaining and running the new software}
Work is still ongoing on a new web-based graphical user interface.  However, the command-line version of the program is ready for use, and can be downloaded and run following the instructions on the project repository:
\begin{center}
\begin{tabular}{rl}
\toprule
\textbf{Instructions and introduction:} & \url{https://github.com/markboots/peg}\\
\textbf{Download:} &\url{https://github.com/markboots/peg/zipball/master}\\
\textbf{Check out with git:}& \url{git://github.com/markboots/peg.git}\\
\textbf{Revision history:}& \url{https://github.com/markboots/peg/commits/master}\\
\bottomrule
\end{tabular}
\end{center}

Table \ref{pegInput} documents the command-line arguments for specifying the grating and incidence configuration.  A copy of the sample output from the program is shown in Figure \ref{pegOutput}.

\renewcommand{\arraystretch}{1.0}
\begin{table}[htbp]
   \centering
   \topcaption{Input Specification (Command-line Arguments) for the \texttt{pegSerial} and \texttt{pegMPI} programs. } % requires the topcapt package
   {\small
   \begin{tabular}{@{} p{3cm}p{12cm} @{}} % Column formatting, @{} suppresses leading/trailing space
      \toprule
\multicolumn{2}{c}{\textbf{Required}}\\
\midrule
\midrule
\multicolumn{2}{l}{\textbf{Grating Specification:}}\\
\midrule
\texttt{--gratingType} & One of: [\texttt{rectangular blazed sinusoidal trapezoidal}]\\
\texttt{--gratingPeriod} & [grating period in um]\\
\texttt{--gratingGeometry} & [command-delimited list of geometry parameters, in um and/or degrees]\\
	&Rectangular profile: depth,valley width\\
	&Blazed profile: blaze angle,anti-blaze angle\\
	&Sinusoidal profile: depth\\
	&Trapezoial profile: depth,valley width,blaze angle,anti-blaze angle\\

\texttt{--gratingMaterial} & [grating substrate material]: 
	This should be a name corresponding to a refractive index database filename, e.g., Au, Ni, C, SiO2, etc.\\
	
\texttt{--N} & [truncation index]: 
	Specifies the number of positive and negative orders to include in the Fourier expansion. Will also determine the number of orders that are calculated, although if you only want to calculate 3 orders, you will still need a much larger truncation index for accurate results.  In the soft X-ray range, convergence is usually attained with $N \sim [15...45]$.\\

\\
\multicolumn{2}{l}{\textbf{Operating Mode:}}\\
\midrule

\texttt{--mode} & One of: [\texttt{constantIncidence} \texttt{constantIncludedAngle} \texttt{constantWavelength}] \\
\texttt{--min} & [min]\\
\texttt{--max} & [max]\\
\texttt{--increment} & [increment]\\
\\
\multicolumn{2}{l}{{Required, depending on the mode:}}\\ 
\\
\texttt{--incidenceAngle} &[incidence angle in degrees]  \\
\texttt{--includedAngle} &[deviation angle in degrees]\\
\texttt{--toOrder} &[diffraction order for the included angle] \\
\texttt{--wavelength} &[wavelength in um]\\

\\

&	In constant incidence mode, a calculation is performed for wavelengths from \texttt{--min} to \texttt{--max} in steps of \texttt{--increment}, at a fixed incidence angle given by \texttt{--incidenceAngle}.\\
&	In constant included angle mode, the incidence angle is calculated at each wavelength to ensure a constant included angle of \texttt{--includedAngle} between the incident light and the order specified in \texttt{--toOrder}. This is the operating mode for many monochromators. (Inside orders are negative, outside orders are positive.)\\
&	In constant wavelength mode, a calculation is performed for incidence angles from \texttt{--min} to \texttt{--max} in steps of \texttt{--increment}, for a fixed wavelength given by \texttt{--wavelength}.\\
	\\

\\
\multicolumn{2}{l}{\textbf{Output:}}\\
\midrule
\texttt{--outputFile} &[file name]:
	The calculation output will be written to this file.\\

\\
\\
\multicolumn{2}{c}{\textbf{\textbf{Optional}}}\\
\midrule
\midrule

\texttt{--progressFile} & [file name]:
	If provided, the current status of the calculation will be written in this file; it can be monitored to determine the progress of long calculations.  This provides an interface for other processes to monitor the status of this calculation (for example, a web-based or GUI front-end, etc.).\\
	
\texttt{--eV} &
	If this flag is included, all wavelength inputs (--min, --max, --increment, and --wavelength) will instead be interpreted as photon energies in electron volts (eV).\\
	
\texttt{--printDebugOutput} &
	If this flag is included, each calculation will print intermediate results to standard output.\\
        \bottomrule
   \end{tabular}
   }
   \label{pegInput}
\end{table}

\begin{table}[htbp]
   \centering
   \topcaption{Output file format for the \texttt{pegSerial} and \texttt{pegMPI} programs.  The Input section restates the program input, the Progress section is updated as the calculation completes, and each row of the Output section lists the independent variable (wavelength, eV, or incidence angle, depending on the mode) followed by the calculated efficiencies for all orders from $-N$ to $N$.} % requires the topcapt package
\begin{lstlisting}[frame=single,numberstyle=\small]
# Input
mode=constantIncidence
incidenceAngle=88
units=eV
min=100
max=120
increment=5
gratingType=blazed
gratingPeriod=1
gratingGeometry=2.5,30
gratingMaterial=Au
N=15
# Progress
status=succeeded
completedSteps=5
totalSteps=5
# Output
100	1.33437e-08,2.01772e-09,3.14758e-08,1.26258e-07,3.16875e-07,6.42301e-07,1.15956e-06,1.96424e-06,3.60516e-06,4.37926e-06,6.85693e-06,1.07995e-05,1.80188e-05,3.47459e-05,0.000100891, 1.0115,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
105	3.10432e-07,1.55365e-07,2.82109e-07,9.94978e-07,2.7072e-06,6.06691e-06,1.24446e-05,2.89393e-05,1.56923e-05,3.91265e-05,6.86083e-05,0.000116368,0.000206277,0.000420725,0.00129465, 0.667446,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
110	1.16288e-07,9.20616e-07,2.97772e-06,6.85694e-06,1.33289e-05,2.35907e-05,4.04132e-05,8.6704e-05,4.52472e-05,0.000100956,0.000160452,0.000247542,0.000404021,0.000767342,0.00219208, 1.57674,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
115	1.33797e-08,1.59323e-09,3.72418e-08,1.49557e-07,3.76447e-07,7.69366e-07,1.42177e-06,3.03323e-06,3.41893e-06,5.4017e-06,8.37909e-06,1.32201e-05,2.21424e-05,4.28869e-05,0.000125008, 1.02805,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
120	2.54404e-07,1.29081e-07,2.35166e-07,8.24594e-07,2.28514e-06,5.43443e-06,1.49531e-05,7.57429e-06,1.89261e-05,3.38267e-05,5.67474e-05,9.52516e-05,0.000168523,0.000344133,0.00106247, 0.706105,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
\end{lstlisting}
   \label{pegOutput}
\end{table}
\renewcommand{\arraystretch}{1.2}

\subsection{Parallel program design and performance}
TODO Parallelization introduction.  (This is reflected in the trend over the past 4 years where computer processor clock speeds have essentially stagnated, but the average number of cores per processor has increased from one to four.)

Based on analysis of the differential method and the use-cases listed above, we identified the following opportunities for parallel decomposition:
\subsubsection{Fine-grained Parallelization}
\label{fineGrained}
Calculating the grating efficiency in all orders $n$ at a single wavelength $\lambda$ can be viewed as a single computation of the ``efficiency function'':
\begin{eqnarray}
e_n = \textrm{eff}(\lambda, p_1, p_2, \ldots),
\end{eqnarray}
where the parameters $p_1, p_2, \ldots$ represent the grating parameters.  

Based on our experience with Gradif, we expect that this single calculation can take from two seconds up to several minutes depending on the grating.  \textbf{Fine-grained parallelization} attempts to speed up a single invocation of the differential method.
\begin{enumerate}
\item In the shooting method, all of the $P=2(2N+1)$ trial solutions need to be numerically integrated from $y=_{m-1}$ to $y=_m$ in each slice.  All of the trial solutions are independent, allowing parallelization of this process over $p$.  Profiling results (Table \ref{timing}) show that this integration, including calculation of the permittivity matrix $M(y)$ at each integration step, represents 99.99\% of the total calculation time. This suggests that this is the (only) worthwhile candidate for parallelization.  When using the S-matrix method, if there are more processors available than trial solutions $P$, we can also parallelize the independent integrations over each layer $m$.
\item The permittivity matrix $M(y)$ must be calculated based on the grating profile, for each grid value along the $y-$axis.  If the integration routine uses a fixed step size, the computation of all the $M$ matrices could be parallelized over grid points.  This is not directly possible if the integration routine uses a dynamic step size, in which case $M$ needs to be evaluated at each integration step.
\item The final step of the shooting method requires inversion of a $2N+1$ linear algebraic system; this could optionally use a parallel iterative solver, but for typical $N$ values from 15 to 45, there is little room for improvement here: the matrix calculations are already small, fast, and fit easily within a single processor's memory space.  With $N=15$, they account for only 0.0095\% of the total run time of the serial program (Table \ref{timing}).
\end{enumerate}

\begin{table}[htbp]
   \begin{center}
\topcaption{Time profile measurements of solver operations, averaged over 5 runs in single-threaded mode.  Essentially all of the time is spent in the integration of the trial solutions, which includes the required calculation of $M(y)$ at each integration step.  This example is for a blazed grating, using $N=15$.}   \begin{tabular}{@{} lr @{}} % Column formatting, @{} suppresses leading/trailing space
      \toprule
	Solver Operation & Percent of Run time\\
      \midrule
Allocate Memory &	0.0004\%	\\
Setup problem variables &	0.0001\%	\\
Compute $\alpha_n$, $\beta^{(M)}_n$, and $\beta^{(1)}_n$ values &	0.0009\%	\\
Integrate all trial solutions &	99.9886\%	\\
Solve linear system for all $A_n$ &	0.0095\%	\\
Compute all $B_n$ &	0.0003\%	\\
Compute and package efficiencies &	0.0001\%	\\
      \bottomrule
   \end{tabular}
   \label{timing}
 \end{center}
 \vspace*{0.2in}  {\footnotesize Test executed with: \texttt{./pegSerial --mode constantIncidence --min 100 --max 120 --increment 5 --incidenceAngle 88 --outputFile testOutput.txt --progressFile testProgress.txt --gratingType blazed --gratingPeriod 1 --gratingMaterial Au --N 15 --gratingGeometry 2.5,30 --eV --measureTiming}}
\end{table}

\subsubsection{Coarse-grained Parallelization}
Fine-grained parallelization over trial solutions has a limit to scaling: it can only use up to $P(M-1)$ processors, if we distribute every trial integration within every layer.  However, all three of the use-cases -- efficiency curves, optimization, and fitting -- require repeated calculations of the efficiency function over different wavelengths or parameters.  Therefore, because all of these calculations can be done completely independently, we can obtain a nearly linear speedup using an ``embarrassingly parallel'' distribution of the computation over wavelength.  This avoids nearly all the overhead of synchronization and communication.  Due to the small amount of information that needs to be shared across processes (wavelength and grating parameters only), this approach could scale to use hundreds or thousands of nodes in a distributed-memory cluster.

\subsubsection{Parallel Implementation}
The fine-grained approach requires substantially more inter-process communication than the coarse-grained approach.  Therefore, we implemented it using the shared-memory programming paradigm using the OpenMP library \cite{openmp08}.  Based on profiling results (Table \ref{timing}), we determined that any performance gained from Option 3 would not be significant enough to make it worth attempting.  Because we chose an adaptive step-size integration algorithm to increase the integration stability, Option 2 was not possible, so we concentrated on implementing parallelization over trial solutions (Option 1).

The coarse-grained parallelization lends itself naturally to distributed-memory computing, and so we implemented it using the Message Passing Interface (MPI) standard \cite{mpi08}.

Modern cluster computers usually contain The two techniques can be used together in a hybrid execution model -- using fine-grained distribution over a the of local processor cores, and coarse distribution over cluster nodes -- takes advantage of the internal architecture of modern cluster computers; this is expected to provides the ultimate theoretical performance.

\subsection{Validation} 
- validate the new implementation against the gradif code
- s-matrix approach: for shallow gratings, results do not change when going from a single layer to arbitrary number of layers (10, 100).  The results are also identical when compared to the basic (non-S-matrix) method described Section TODO. For deep gratings that showed instability at some wavelengths, the S-matrix implementation removes these instabilities, but also converges to the stable non-S-matrix results. (Figure \ref{} LEG example ).
- coatings: 0 thickness coating. Thick null coating (no change to six significant figures.)
\subsection{New web interface}
\subsection{Future work}

